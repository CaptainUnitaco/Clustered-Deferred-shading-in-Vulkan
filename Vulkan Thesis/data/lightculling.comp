#version 450
#extension GL_ARB_separate_shader_objects : enable


#define TILE_SIZE 32 // TODO bake it with compilation or w/e
#define PAGE_SIZE 512
#define PAGE_SIZE_POWER 9
#define Y_SLICES 0.027398974188114442743140954270042618454096202801626751934

// ------------- STRUCTS -------------
struct Light
{
	vec3 position;
	float radius;
	vec3 intensity;
	float pad;
};

struct ViewFrustum
{
	vec3 plane[6];
	float near;
	float far;
};

// ------------- LAYOUTS -------------
layout(set = 0, binding = 0) uniform CameraUBO
{
	mat4 view;
	mat4 proj;
	mat4 invProj;
	vec3 position;
} camera;

layout(std430, set = 1, binding = 0) buffer readonly LightsIn
{
	uvec3 lightCount_screenSize;
	uint pad;
	Light lightsIn[];
};

layout(std430, set = 1, binding = 1) buffer writeonly LightsOut
{
	uint count;
	uint lights[];
} lightsOut;

layout(std430, set = 1, binding = 4) buffer readonly PageTable
{
	uint counter;
	uint nodes[];
} table;

layout(std430, set = 1, binding = 5) buffer writeonly PagePool
{
	uint data[];
} pool;

layout(std430, set = 1, binding = 6) buffer readonly CompactedClusters
{
	uint counter;
	uint data[];
} comp;

// ------------- VARIABLES -------------
ViewFrustum createFrustum(uvec3 clusterID)
{
	ViewFrustum frustum;

	// frustum.near = -exp(clusterID.z * Y_SLICES) * 0.5;
	// frustum.far = -exp((clusterID.z + 1) * Y_SLICES) * 0.5;
	// frustum.near = ( -frustum.near * (100.0 + 0.5) / (100.0 - 0.5) - 2 * 100.0 * 0.5 / (100.0 - 0.5) ) / -frustum.near;
	// frustum.far = ( -frustum.far * (100.0 + 0.5) / (100.0 - 0.5) - 2 * 100.0 * 0.5 / (100.0 - 0.5) ) / -frustum.far;

	frustum.near = (1.0 / (exp(clusterID.z * Y_SLICES) * 0.5) - 2) / -1.99;
	frustum.far = (1.0 / (exp((clusterID.z + 1) * Y_SLICES) * 0.5) - 2) / -1.99;
	// frustum.near = 2.0 * frustum.near - 1.0;
	// frustum.far = 2.0 * frustum.far - 1.0;
	
	uvec2 tileCount = (lightCount_screenSize.yz - 1) / TILE_SIZE + 1;
	uvec2 tileID = clusterID.xy;
	vec2 step = 2.0 * vec2(TILE_SIZE, TILE_SIZE) / vec2(tileCount * TILE_SIZE);

	vec2 ndc[4];
	ndc[0] = vec2(step * tileID - 1.0); // top left	
	ndc[1] = vec2(ndc[0].x, ndc[0].y + step.y); // bottom left
	ndc[2] = vec2(ndc[0].x + step.x, ndc[1].y); // botom right
	ndc[3] = vec2(ndc[2].x, ndc[0].y); // top right

	vec4 frustumPoints[8];
	for (uint i = 0; i < 4; i++) 
	{
		frustumPoints[i] = camera.invProj * vec4(ndc[i], frustum.near, 1.0);
		frustumPoints[i] /= frustumPoints[i].w;
		frustumPoints[i + 4] = camera.invProj * vec4(ndc[i], frustum.far, 1.0);
		frustumPoints[i + 4] /= frustumPoints[i + 4].w;
	}

	for (uint i = 0; i < 4; i++)
		frustum.plane[i] = normalize(cross(frustumPoints[i].xyz, frustumPoints[(i + 1) & 3].xyz));

	frustum.far = frustumPoints[0].z;
	frustum.near = frustumPoints[4].z;

	// near
	frustum.plane[4] = normalize(cross(frustumPoints[3].xyz - frustumPoints[0].xyz, frustumPoints[1].xyz - frustumPoints[0].xyz));

	// far
	frustum.plane[5] = normalize(cross(frustumPoints[5].xyz - frustumPoints[4].xyz, frustumPoints[7].xyz - frustumPoints[4].xyz));

	return frustum;
}

bool collide(ViewFrustum frustum, vec3 position, float radius)
{
	for (uint i = 0; i < 4; i++)
	{
		// float distance = dot(frustum.plane[i], position) + radius;

		// if (distance <= 0.0)
		// 	return false;
		float distance = dot(frustum.plane[i], position);

		if (distance > radius)
			return false;
	}
	if (position.z < frustum.near - radius || position.z > frustum.far + radius)
		return false;

	// if (position.z > frustum.far + radius)
	// 	return false;

	return true;
}

uint addressTranslate(uint virtualAddress)
{
	uint pageNumber = virtualAddress >> PAGE_SIZE_POWER;
	uint pageAddress = (table.nodes[pageNumber] - 2) * PAGE_SIZE;
	uint offset = virtualAddress % PAGE_SIZE;

	return pageAddress + offset;
}

layout(local_size_x = 64) in;
void main()
{
	if (gl_LocalInvocationIndex == 0)
	{
		lightsOut.lights[0] = 0; // used as dummy for cluster without light
		lightsOut.count = 1;
	}

	barrier();

	for (uint i = gl_LocalInvocationIndex; i < comp.counter; i += 64)
	{
		uint key = comp.data[i];
		ViewFrustum frustum = createFrustum(uvec3(key & 0x7F, (key >> 7) & 0x7F, key >> 14));

		uint lightCount = 0;
		uint lightIndices[256];

		for (uint x = 0; x < lightCount_screenSize.x; x++)
		{
			vec3 position = (camera.view * vec4(lightsIn[x].position, 1.0)).xyz;
			if (collide(frustum, position, lightsIn[x].radius))
			{
				lightIndices[lightCount++] = x;
			}				
		}

		if (i == 0)
		{
			uint index = atomicAdd(lightsOut.count, 4);
			vec4 position = camera.view * vec4(lightsIn[0].position, 1.0);
			lightsOut.lights[index++] = floatBitsToUint(frustum.near);
			lightsOut.lights[index++] = floatBitsToUint(frustum.far);
			lightsOut.lights[index++] = floatBitsToUint(position.z);
			lightsOut.lights[index++] = key >> 14;
		}

		if (lightCount > 0)
		{
			uint index = atomicAdd(lightsOut.count, lightCount + 1);
			pool.data[addressTranslate(key)] = index;
			lightsOut.lights[index++] = lightCount;
			
			for (uint x = 0; x < lightCount; x++)
				lightsOut.lights[index + x] = lightIndices[x];
		}
		else
			pool.data[addressTranslate(key)] = 0; // point to dummy
	}
}