#version 450
#extension GL_ARB_separate_shader_objects : enable

#define PAGE_SIZE 512 // 2^9 TODO push constants?
#define LOCAL_SIZE 256
layout(std430, set = 1, binding = 4) buffer readonly PageTable
{
	uint counter;
	uint nodes[];
} table;

layout(std430, set = 1, binding = 5) buffer PagePool
{
	uint data[];
} pool;

layout(std430, set = 1, binding = 6) buffer writeonly CompactedClusters
{
	uint counter;
	uint data[];
} comp;

layout(std430, set = 1, binding = 1) buffer writeonly LightsOut
{
	uint count;
	uint lights[];
} lightsOut;

shared uint clusterCounter;
shared uint globalCounterState;
shared uint clusterIndices[2046];

layout(local_size_x = LOCAL_SIZE) in;
void main()
{
	uint tid = gl_LocalInvocationIndex;

	if (tid == 0)
		clusterCounter = 0;

	barrier();

	for (uint i = gl_GlobalInvocationID.x; i < PAGE_SIZE * table.counter; i += LOCAL_SIZE * gl_NumWorkGroups.x)
	{
		if (pool.data[i] > 0)
		{
			uint index = atomicAdd(clusterCounter, 1);
			clusterIndices[index] = i;
		}
	}

	barrier();

	if (tid == 0)
		globalCounterState = atomicAdd(comp.counter, clusterCounter);

	barrier();

	// write to the global memory
	for (uint i = tid; i < clusterCounter; i += LOCAL_SIZE)
	{
		uint clusterID = clusterIndices[i];
		comp.data[i + globalCounterState] = pool.data[clusterID];
		pool.data[clusterID] = i + globalCounterState;
	}

	if (gl_GlobalInvocationID.x == 0) // TODO fill through vkCmd
	{
		// prepare lights out for next dispatch
		lightsOut.lights[0] = 0; // used as dummy for cluster without light
		lightsOut.count = 1;
	}
}