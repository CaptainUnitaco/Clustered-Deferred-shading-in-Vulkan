#version 450
#extension GL_ARB_separate_shader_objects : enable
#extension GL_GOOGLE_include_directive : require

#define LOCAL_SIZE 256

// ------------- STRUCTS -------------
struct Light
{
	vec3 position;
	float radius;
	vec3 intensity;
	uint mortonCode;
};

struct Key
{
	uint mortonCode;
	uint lightIndex;
};

layout(std430, set = 1, binding = 0) buffer LightsIn
{
	uvec3 lightCount_screenSize;
	uint pad;
	Light lightsIn[];
};

layout(std430, set = 1, binding = 1) buffer Splitter
{
	// Key kyes[];
	Key data[];
} splitters;

shared uint mortons[LOCAL_SIZE];
shared uint indices[LOCAL_SIZE];

#include "sort_util.comp"

layout(local_size_x = LOCAL_SIZE) in;
void main()
{
	uint tid = gl_LocalInvocationIndex;
	uint lightCount = lightCount_screenSize.x;

	// take every 256th
	uint idx = (gl_GlobalInvocationID.x + 1) << 8;
	if (idx >= lightCount) idx = lightCount - 1;
	uint morton = lightsIn[idx].mortonCode;
	
	mortons[tid] = morton;
	indices[tid] = tid;

	barrier();

	mergeSort(gl_GlobalInvocationID.x);
	splitters.data[indices[tid]].lightIndex = idx;
	splitters.data[indices[tid]].mortonCode = morton;
}

// void splitterSort2_16()
// {
// 	uint tid = gl_LocalInvocationIndex;
// 	uint lightCount = lightCount_screenSize.x;

// 	// take every 2^16 element
// 	uint idx = (gl_GlobalInvocationID.x + 1) << 8;
// 	mortons[tid] = (idx < lightCount) ? splitters.data[idx].mortonCode : ~0;
// 	indices[tid] = idx;

// 	barrier();

// 	mergeSort();
// 	splitters.data[gl_GlobalInvocationID.x] = indices[tid];
// }