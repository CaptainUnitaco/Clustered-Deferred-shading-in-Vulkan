#version 450
#extension GL_ARB_separate_shader_objects : enable
#extension GL_GOOGLE_include_directive : require
#extension GL_EXT_control_flow_attributes : enable
#extension GL_KHR_shader_subgroup_arithmetic : enable

#define LOCAL_SIZE 512
#define LOCAL_SIZE_POWER 9
#define WARP_COUNT LOCAL_SIZE / 32

// ------------- STRUCTS -------------
#include "structs.inl"

layout(std430, set = 1, binding = 0) buffer LightsIn
{
	uvec3 lightCount_screenSize;
	uint pad;
	Light lightsIn[];
};

layout(std430, set = 1, binding = 1) buffer readonly Lights
{
	Key data[];
} lights;

layout(std430, set = 1, binding = 2) buffer writeonly Keys
{
	uint keys[];
};

layout(std430, set = 1, binding = 2) buffer writeonly BVH
{
	// LevelParam level[5];
	Node nodes[];
} bvh;

layout(push_constant) uniform pushConstants 
{
	uint offset;
};


layout(local_size_x = LOCAL_SIZE) in;
void main()
{		
	// discard warps out of bounds
	if ((gl_GlobalInvocationID.x & ~(gl_SubgroupSize - 1)) > lightCount_screenSize.x)
		return;

	uint ii = (gl_GlobalInvocationID.x < lightCount_screenSize.x) ? gl_GlobalInvocationID.x : lightCount_screenSize.x - 1;
	ii = lights.data[ii].lightIndex;

	keys[gl_GlobalInvocationID.x] = ii;
	
	Node node;
	node.min = subgroupMin(lightsIn[ii].position - lightsIn[ii].radius);
	node.max = subgroupMax(lightsIn[ii].position + lightsIn[ii].radius);

	if (subgroupElect())
		bvh.nodes[gl_GlobalInvocationID.x / gl_SubgroupSize + offset] = node;
}